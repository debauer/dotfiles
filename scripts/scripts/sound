#!/usr/bin/env python3

from argparse import ArgumentParser
from dataclasses import dataclass

from typing import List

import pulsectl
from pulsectl import PulseSinkInfo, PulseClientInfo, PulseOperationFailed, PulseSinkInputInfo

pulse = pulsectl.Pulse("my-client-name")

@dataclass
class SinkDefinition:
    name: str
    device_name: str
    
class Sinks:
    sinks = [
        SinkDefinition("internal", "Family 17h/19h HD Audio Controller"),
        SinkDefinition("boxen", "Sound Blaster Play!"),
        SinkDefinition("bayer", "USB HIFI Audio"),
        SinkDefinition("bose", "Bose David")
    ]
    
    def get_sink_names(self):
        return [s.name for s in self.sinks]
    
    def get_sink_by_name(self, name: str) -> SinkDefinition:
        for s in self.sinks:
            if s.name == name:
                return s
        raise ValueError(f"sink not found {name=}")

    def get_sink_by_device_name(self, device_name: str) -> SinkDefinition:
        for s in self.sinks:
            if s.device_name == device_name:
                return s
        return SinkDefinition("NOT DEFINED","NOT DEFINED")
        #raise ValueError(f"sink not found {device_name=}")

my_sinks = Sinks()

def find_sink(name: str, verbose: bool = False) -> PulseSinkInfo:
    sinks: List[PulseSinkInfo] = pulse.sink_list()
    for s in sinks:
        if s.proplist["device.description"] == my_sinks.get_sink_by_name(name):
            if verbose:
                print("found sink:")
                print(" ", s)
            return s
        
def default_sink(verbose: bool = False) -> None:
    sinks: List[PulseSinkInfo] = pulse.sink_list()
    for s in sinks:
        if verbose:
            if s.proplist["node.name"] == pulse.server_info().default_sink_name:
                print("default sink:")
                print(" ", my_sinks.get_sink_by_device_name(s.proplist["device.description"]))
    
        
def active_sink(verbose: bool = False) -> PulseSinkInfo:
    sinks: List[PulseSinkInfo] = pulse.sink_list()
    for s in sinks:
        if s.state._value == "running":
            if verbose:
                print("active sink:")
                print(" ", my_sinks.get_sink_by_device_name(s.proplist["device.description"]))
            return s

def available_sinks(verbose: bool = False) -> None:
    sinks: List[PulseSinkInfo] = pulse.sink_list()
    if verbose:
        print("available sinks:")
        print()
        print(f'long name                                     || name          || state        || device.id')
        print(f'- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -')
        for s in sinks:
            print(f'{s.proplist["device.description"]:<45} || {my_sinks.get_sink_by_device_name(s.proplist["device.description"]).name:<13} || {s.state._value:<12} || device.id: {s.proplist["device.id"]}')

def available_input_sinks(verbose: bool = False) -> List[PulseSinkInputInfo]:
    sinks: List[PulseSinkInputInfo] = pulse.sink_input_list()
    if verbose:
        print("available input sinks:")
        for s in sinks:
            print(" ", s.proplist["application.name"])
    return sinks

def available_clients(verbose: bool = False) -> List[PulseClientInfo]:
    playbacks: List[PulseClientInfo] = pulse.client_list()
    if verbose:
        print("available clients:")
        for p in playbacks:
            print(f' {p.proplist["application.name"]} (id:{p.index})')
    return playbacks
        


def menue_item():
    return my_sinks

def parse():
    parser = ArgumentParser(description="System to record the data on a trimodal crane")
    parser.add_argument("-d", "--device", type=str, help="device", choices=my_sinks.get_sink_names())
    parser.add_argument("-v", "--verbose", action='store_const', const="verbose", help="verbose")
    return parser.parse_args()


def switch(device: str, verbose: bool):
    if verbose:
        print(pulse.sink_input_list())
    sink = find_sink(device)
    input_sinks = available_input_sinks()


    pulse.sink_default_set(sink)
    for input_sink in input_sinks:
        try:
            pulse.sink_input_move(input_sink.index, sink.index)
        except PulseOperationFailed:
            print(f"failed {input_sink.proplist['application.name']}")
        except AttributeError:
            available_sinks(verbose=True) 
            print("NO SINK FOUND")
            return
    print("DONE")



def _main():
    args = parse()
    verbose = args.verbose
    device = args.device
    
    active_sink(verbose)
    available_sinks(verbose) 
    available_clients(verbose)
    default_sink(verbose)
    
    if device is not None:
        switch(device, verbose)
    else: 
        available_sinks(verbose=True) 
    #notify("sound.py", "1337", f"changed sink to: {device}")
    exit()

if __name__ == "__main__":
    _main()
    
